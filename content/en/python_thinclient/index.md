---
title: "Katzenpost Python Thin Client"
linkTitle: "Katzenpost Python Thin Client"
url: "docs/python_thin_client.html"
description: ""
categories: [""]
tags: [""]
author: ["David Stainton"]
version: 0
draft: false
---

<!-- spacer -->

&nbsp;

&nbsp;

# katzenpost\_thinclient

Katzenpost Python Thin Client
=============================

This module provides a minimal async Python client for communicating with the
Katzenpost client daemon over an abstract Unix domain socket. It allows
applications to send and receive messages via the mix network by interacting
with the daemon.

The thin client handles:
- Connecting to the local daemon
- Sending messages
- Receiving events and responses from the daemon
- Accessing the current PKI document and service descriptors

All cryptographic operations, including PQ Noise transport, Sphinx
packet construction, and retransmission mechanisms are handled by the
client daemon, and not this thin client library.

For more information, see our client integration guide:
https://katzenpost.network/docs/client_integration/


Usage Example
-------------

```python
import asyncio
from thinclient import ThinClient, Config

def on_message_reply(event):
    print("Got reply:", event)

async def main():
    cfg = Config("./thinclient.toml", on_message_reply=on_message_reply)
    client = ThinClient(cfg)
    loop = asyncio.get_running_loop()
    await client.start(loop)

    service = client.get_service("echo")
    surb_id = client.new_surb_id()
    client.send_message(surb_id, "hello mixnet", *service.to_destination())

    await client.await_message_reply()

asyncio.run(main())
```

<a id="katzenpost_thinclient.Geometry"></a>

## Geometry Objects

```python
class Geometry()
```

Geometry describes the geometry of a Sphinx packet.

NOTE: You must not try to compose a Sphinx Geometry yourself.
It must be programmatically generated by Katzenpost
genconfig or gensphinx CLI utilities.

We describe all the Sphinx Geometry attributes below, however
the only one you are interested in to faciliate your thin client
message bounds checking is UserForwardPayloadLength, which indicates
the maximum sized message that you can send to a mixnet service in
a single packet.

**Attributes**:

- `PacketLength` _int_ - The total length of a Sphinx packet in bytes.
- `NrHops` _int_ - The number of hops; determines the header's structure.
- `HeaderLength` _int_ - The total size of the Sphinx header in bytes.
- `RoutingInfoLength` _int_ - The length of the routing information portion of the header.
- `PerHopRoutingInfoLength` _int_ - The length of routing info for a single hop.
- `SURBLength` _int_ - The length of a Single-Use Reply Block (SURB).
- `SphinxPlaintextHeaderLength` _int_ - The length of the unencrypted plaintext header.
- `PayloadTagLength` _int_ - The length of the tag used to authenticate the payload.
- `ForwardPayloadLength` _int_ - The size of the full payload including padding and tag.
- `UserForwardPayloadLength` _int_ - The usable portion of the payload intended for the recipient.
- `NextNodeHopLength` _int_ - Derived from the expected maximum routing info block size.
- `SPRPKeyMaterialLength` _int_ - The length of the key used for SPRP (Sphinx packet payload encryption).
- `NIKEName` _str_ - Name of the NIKE scheme (if used). Mutually exclusive with KEMName.
- `KEMName` _str_ - Name of the KEM scheme (if used). Mutually exclusive with NIKEName.

<a id="katzenpost_thinclient.ConfigFile"></a>

## ConfigFile Objects

```python
class ConfigFile()
```

ConfigFile represents everything loaded from a TOML file:
network, address, and geometry.

<a id="katzenpost_thinclient.pretty_print_obj"></a>

#### pretty\_print\_obj

```python
def pretty_print_obj(obj)
```

Pretty-print a Python object using indentation.

This function uses `pprintpp` to print complex data structures
(e.g., dictionaries, lists) in a readable, indented format.

**Arguments**:

- `obj` _Any_ - The object to pretty-print.

<a id="katzenpost_thinclient.ServiceDescriptor"></a>

## ServiceDescriptor Objects

```python
class ServiceDescriptor()
```

Describes a mixnet service endpoint retrieved from the PKI document.

A ServiceDescriptor encapsulates the necessary information for communicating
with a service on the mix network. The service node's identity public key's hash
is used as the destination address along with the service's queue ID.

**Attributes**:

- `recipient_queue_id` _bytes_ - The identifier of the recipient's queue on the mixnet.
- `mix_descriptor` _dict_ - A CBOR-decoded dictionary describing the mix node,
  typically includes the 'IdentityKey' and other metadata.
  

**Methods**:

- `to_destination()` - Returns a tuple of (provider_id_hash, recipient_queue_id),
  where the provider ID is a 32-byte BLAKE2b hash of the IdentityKey.

<a id="katzenpost_thinclient.find_services"></a>

#### find\_services

```python
def find_services(capability, doc)
```

Search the PKI document for services supporting the specified capability.

This function iterates over all service nodes in the PKI document,
deserializes each CBOR-encoded node, and looks for advertised capabilities.
If a service provides the requested capability, it is returned as a
`ServiceDescriptor`.

**Arguments**:

- `capability` _str_ - The name of the capability to search for (e.g., "echo").
- `doc` _dict_ - The decoded PKI document as a Python dictionary,
  which must include a "ServiceNodes" key containing CBOR-encoded descriptors.
  

**Returns**:

- `List[ServiceDescriptor]` - A list of matching service descriptors that advertise the capability.
  

**Raises**:

- `KeyError` - If the 'ServiceNodes' field is missing from the PKI document.

<a id="katzenpost_thinclient.Config"></a>

## Config Objects

```python
class Config()
```

Config is the configuration object for the ThinClient.

<a id="katzenpost_thinclient.Config.__init__"></a>

#### \_\_init\_\_

```python
def __init__(filepath,
             on_connection_status=None,
             on_new_pki_document=None,
             on_message_sent=None,
             on_message_reply=None)
```

Initialize the Config object.

**Arguments**:

- `filepath` _str_ - Path to the TOML config file.
- `on_connection_status` _callable_ - Callback for connection status events.
- `on_new_pki_document` _callable_ - Callback for new PKI document events.
- `on_message_sent` _callable_ - Callback for sent message events.
- `on_message_reply` _callable_ - Callback for message reply events.

<a id="katzenpost_thinclient.ThinClient"></a>

## ThinClient Objects

```python
class ThinClient()
```

A minimal Katzenpost Python thin client for communicating with the local
Katzenpost client daemon over a UNIX or TCP socket.

The thin client is responsible for:
- Establishing a connection to the client daemon.
- Receiving and parsing PKI documents.
- Sending messages to mixnet services (with or without SURBs).
- Handling replies and events via user-defined callbacks.

All cryptographic operations are handled by the daemon, not by this client.

<a id="katzenpost_thinclient.ThinClient.__init__"></a>

#### \_\_init\_\_

```python
def __init__(config)
```

Initialize the thin client with the given configuration.

**Arguments**:

- `config` _Config_ - The configuration object containing socket details and callbacks.
  

**Raises**:

- `RuntimeError` - If the network type is not recognized or config is incomplete.

<a id="katzenpost_thinclient.ThinClient.start"></a>

#### start

```python
async def start(loop)
```

Start the thin client: establish connection to the daemon, read initial events,
and begin the background event loop.

**Arguments**:

- `loop` _asyncio.AbstractEventLoop_ - The running asyncio event loop.

<a id="katzenpost_thinclient.ThinClient.get_config"></a>

#### get\_config

```python
def get_config()
```

Returns the current configuration object.

**Returns**:

- `Config` - The client configuration in use.

<a id="katzenpost_thinclient.ThinClient.stop"></a>

#### stop

```python
def stop()
```

Gracefully shut down the client and close its socket.

<a id="katzenpost_thinclient.ThinClient.recv"></a>

#### recv

```python
async def recv(loop)
```

Receive a CBOR-encoded message from the daemon.

**Arguments**:

- `loop` _asyncio.AbstractEventLoop_ - Event loop to use for socket reads.
  

**Returns**:

- `dict` - Decoded CBOR response from the daemon.
  

**Raises**:

- `ValueError` - If message framing fails.

<a id="katzenpost_thinclient.ThinClient.worker_loop"></a>

#### worker\_loop

```python
async def worker_loop(loop)
```

Background task that listens for events and dispatches them.

<a id="katzenpost_thinclient.ThinClient.parse_status"></a>

#### parse\_status

```python
def parse_status(event)
```

Parse a connection status event and assert daemon connectivity.

<a id="katzenpost_thinclient.ThinClient.pki_document"></a>

#### pki\_document

```python
def pki_document()
```

Retrieve the latest PKI document received.

**Returns**:

- `dict` - Parsed CBOR PKI document.

<a id="katzenpost_thinclient.ThinClient.parse_pki_doc"></a>

#### parse\_pki\_doc

```python
def parse_pki_doc(event)
```

Parse and store a new PKI document received from the daemon.

<a id="katzenpost_thinclient.ThinClient.get_services"></a>

#### get\_services

```python
def get_services(capability)
```

Look up all services in the PKI that advertise a given capability.

**Arguments**:

- `capability` _str_ - Capability name (e.g., "echo").
  

**Returns**:

- `list[ServiceDescriptor]` - Matching services.
  

**Raises**:

- `Exception` - If PKI is missing or no services match.

<a id="katzenpost_thinclient.ThinClient.get_service"></a>

#### get\_service

```python
def get_service(service_name)
```

Select a random service matching a capability.

**Arguments**:

- `service_name` _str_ - The capability name (e.g., "echo").
  

**Returns**:

- `ServiceDescriptor` - One of the matching services.

<a id="katzenpost_thinclient.ThinClient.new_message_id"></a>

#### new\_message\_id

```python
def new_message_id()
```

Generate a new 16-byte message ID for use with ARQ sends.

**Returns**:

- `bytes` - Random 16-byte identifier.

<a id="katzenpost_thinclient.ThinClient.new_surb_id"></a>

#### new\_surb\_id

```python
def new_surb_id()
```

Generate a new 16-byte SURB ID for reply-capable sends.

**Returns**:

- `bytes` - Random 16-byte identifier.

<a id="katzenpost_thinclient.ThinClient.handle_response"></a>

#### handle\_response

```python
def handle_response(response)
```

Dispatch a parsed CBOR response to the appropriate handler or callback.

<a id="katzenpost_thinclient.ThinClient.send_message_without_reply"></a>

#### send\_message\_without\_reply

```python
def send_message_without_reply(payload, dest_node, dest_queue)
```

Send a fire-and-forget message with no SURB or reply handling.

**Arguments**:

- `payload` _bytes or str_ - Message payload.
- `dest_node` _bytes_ - Destination node identity hash.
- `dest_queue` _bytes_ - Destination recipient queue ID.

<a id="katzenpost_thinclient.ThinClient.send_message"></a>

#### send\_message

```python
def send_message(surb_id, payload, dest_node, dest_queue)
```

Send a message using a SURB to allow the recipient to send a reply.

**Arguments**:

- `surb_id` _bytes_ - SURB identifier for reply correlation.
- `payload` _bytes or str_ - Message payload.
- `dest_node` _bytes_ - Destination node identity hash.
- `dest_queue` _bytes_ - Destination recipient queue ID.

<a id="katzenpost_thinclient.ThinClient.send_reliable_message"></a>

#### send\_reliable\_message

```python
def send_reliable_message(message_id, payload, dest_node, dest_queue)
```

Send a reliable message using an ARQ mechanism and message ID.

**Arguments**:

- `message_id` _bytes_ - Message ID for reply correlation.
- `payload` _bytes or str_ - Message payload.
- `dest_node` _bytes_ - Destination node identity hash.
- `dest_queue` _bytes_ - Destination recipient queue ID.

<a id="katzenpost_thinclient.ThinClient.pretty_print_pki_doc"></a>

#### pretty\_print\_pki\_doc

```python
def pretty_print_pki_doc(doc)
```

Pretty-print a parsed PKI document with fully decoded CBOR nodes.

**Arguments**:

- `doc` _dict_ - Raw PKI document from the daemon.

<a id="katzenpost_thinclient.ThinClient.await_message_reply"></a>

#### await\_message\_reply

```python
async def await_message_reply()
```

Asynchronously block until a reply is received from the daemon.

