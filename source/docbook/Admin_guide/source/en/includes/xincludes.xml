<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.1/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.1/sch/docbook.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>

<!DOCTYPE article [
    <!ENTITY % shared-content SYSTEM "../../../../shared-content.ent">
    %shared-content;
]>

<!--Using these includes multiple times in a document creates problems with ID duplication, breaking validation. 
This group of includes is fashioned to have block-level wrappers that do not reference an ID. To invoke them, I
instead use the "XPointer element() Scheme", which permits me to reference them using a DOM-like address. The result 
is quite fragile. The order of the includes cannot be changed without also changing the xpointer configurations in the 
documents where they occur.

References:

XPointer element() Scheme: 
https://www.w3.org/TR/2003/REC-xptr-element-20030325/
https://en.wikipedia.org/wiki/XPointer#Positional_element_addressing

Practical guidance on address syntax: 
https://stackoverflow.com/questions/16563106/how-to-use-xpointer-with-xinclude-to-reference-elements
https://github.com/tomschr/xpointer-example

From Wikipedia:

<foobar id="foo">
  <bar/>
  <baz>
    <bom a="1"/>
  </baz>
  <bom a="2"/>
</foobar>

results as the following examples:

 xpointer(id("foo")) => foobar
 xpointer(/foobar/1) => bar
 xpointer(//bom) => bom (a=1), bom (a=2)
 element(/1/2/1) => bom (a=1) (/1 descend into first element (foobar),
                               /2 descend into second child element (baz),
                               /1 select first child element (bom))

In these documents, we reference items in THIS FILE as follows:

    <xi:include  
        href="includes/xincludes.xml"
        xpointer="element(/1/7)"  
        xmlns:xi="http://www.w3.org/2001/XInclude" />
        
This means, "Descend into the first element (chapter), then descend into its seventh direct child element (<simplesect>),
which happens to be the serverdebug include include below. Calling /1/7 returns all content of that <simplesect>
element recursively. I have to depend on comment tags to keep track of what is what.
-->


<!--TOC (with element number):
serverconfig (/1/2)
logging (/1/3)
sphinxgeometry (/1/4)
management (/1/5)
pki (/1/6)
serverdebug (/1/7)-->

<chapter xml:id="xincludes"  xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.1">
    
    <title xml:id="xincludes.title">XIncludes repository</title>

    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->   
    
    <!-- serverconfig (/1/2) -->
    
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->   
    
    
    <!-- Note -->
    <!-- To remedy confusion concerning Addresses and BindAddresses, here is the relevant csource code. -->
    
    <!--
        
    In server/config/config.go : 
    
    
    type Server struct {
    // Identifier is the human readable identifier for the node (eg: FQDN).
    Identifier string
    
    // WireKEM is the KEM string representing the chosen KEM scheme with which to communicate
    // with the mixnet and dirauth nodes.
    WireKEM string
    
    // PKISignatureScheme specifies the cryptographic signature scheme
    PKISignatureScheme string
    
    // Addresses are the IP listener addresses that the server will advertise
    // in the PKI and bind to for incoming connections unless BindAddresses is specified.
    Addresses []string
    
    // BindAddresses are the listener addresses that the server will bind to and accept connections on
    // These Addresses are not advertised in the PKI.
    BindAddresses []string
    
    ....  
    
    func (sCfg *Server) validate() error {
    if sCfg.Identifier == "" {
    return errors.New("config: Server: Identifier is not set")
    }
    
    if sCfg.WireKEM == "" {
    return errors.New("config: Server: WireKEM is not set")
    }
    
    if sCfg.PKISignatureScheme == "" {
    return errors.New("config: Server: PKISignatureScheme is not set")
    }
    
    if sCfg.Addresses != nil {
    for _, v := range append(sCfg.Addresses, sCfg.BindAddresses...) {
    if u, err := url.Parse(v); err != nil {
    return fmt.Errorf("config: Authority: Address '%v' is invalid: %v", v, err)
    } else if u.Port() == "" {
    return fmt.Errorf("config: Authority: Address '%v' is invalid: Must contain Port", v)
    }
    }
    } else {
    // Try to guess a "suitable" external IPv4 address.  If people want
    // to do loopback testing, they can manually specify one.  If people
    // want to use IPng, they can manually specify that as well.
    addr, err := utils.GetExternalIPv4Address()
    if err != nil {
    return err
    }
    
    sCfg.Addresses = []string{"tcp://" + addr.String() + defaultAddress}
    }
    
    internalTransports := make(map[string]bool)
    for _, v := range pki.InternalTransports {
    internalTransports[strings.ToLower(string(v))] = true
    }
    
    if !filepath.IsAbs(sCfg.DataDir) {
    return fmt.Errorf("config: Server: DataDir '%v' is not an absolute path", sCfg.DataDir)
    }
    if sCfg.MetricsAddress != "" {
    if _, err := netip.ParseAddrPort(sCfg.MetricsAddress); err != nil {
    return fmt.Errorf("config: Server: MetricsAddress '%v' is invalid: %v", sCfg.MetricsAddress, err)
    }
    }
    return nil
    }
    
    
    
    In server/server.go :
    
    // Initialize the outgoing connection manager, decoy source/sink, and then
    // start the PKI worker.
    s.connector = outgoing.New(goo)
    if s.decoy, err = decoy.New(goo); err != nil {
    s.log.Errorf("Failed to initialize decoy source/sink: %v", err)
    return nil, err
    }
    
    var addresses []string
    if len(s.cfg.Server.BindAddresses) > 0 {
    s.log.Debugf("BindAddresses found")
    addresses = s.cfg.Server.BindAddresses
    } else {
    addresses = s.cfg.Server.Addresses
    }
    // Bring the listener(s) online.
    s.listeners = make([]glue.Listener, 0, len(addresses))
    for i, addr := range addresses  {
    l, err := incoming.New(goo, s.inboundPackets, i, addr)
    if err != nil {
    s.log.Errorf("Failed to spawn listener on address: %v (%v).", addr, err)
    return nil, err
    }
    s.listeners = append(s.listeners, l)
    }
     
In docker/voting_mixnet/gateway1/katzenpost.toml :

[Server]
  Identifier = "gateway1"
  WireKEM = "xwing"
  PKISignatureScheme = "Ed448-Dilithium3"
  Addresses = ["tcp://127.0.0.1:30004", "quic://[::1]:30005", "onion://thisisjustatestoniontoverifythatconfigandpkiworkproperly.onion:4242"]
  BindAddresses = ["tcp://127.0.0.1:30004", "quic://[::1]:30005"]
  MetricsAddress = "127.0.0.1:30006"
  DataDir = "/voting_mixnet/gateway1"
  IsGatewayNode = true
  IsServiceNode = false
-->
   
    <simplesect>
        <title></title>
        <!--The config code varies by role so it is not included in this entity.-->       
        <informalexample> 
            <itemizedlist>
                <listitem>
                    <para><emphasis role="bold">Identifier</emphasis></para>
                    <para>Specifies the human-readable identifier for a node, and must be unique per mixnet. 
                        The identifier can be an FQDN but does not have to be.</para>
                    <para>Type: string</para>
                    <para>Required: Yes</para>
                </listitem>
                
                &WireKEM;
                
                <listitem>
                    <para><emphasis role="bold">PKISignatureScheme</emphasis></para>
                    <para>Specifies the cryptographic signature scheme that will be used by all
                        components of the mix network when interacting with the PKI system. Mix
                        nodes sign their descriptors using this signature scheme, and dirauth nodes
                        similarly sign PKI documents using the same scheme.</para>
                    <para>The following signature schemes are supported:</para>
                    <itemizedlist>
                        <listitem>
                            <para><emphasis role="bold">Classical:</emphasis>  "ed25519", "ed448"</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">Hybrid post-quantum:</emphasis> "Ed25519
                                Sphincs+", "Ed448-Sphincs+", "Ed25519-Dilithium2",
                                "Ed448-Dilithium3" </para>
                        </listitem>
                    </itemizedlist>
                    <para>Type: string</para>
                    <para>Required: Yes</para>
                </listitem>
                
                <listitem>
                    <para><emphasis role="bold">Addresses</emphasis></para>
                    <para>Specifies a list of one or more address URLs in a format that contains the
                        transport protocol, IP address, and port number that the server will bind to
                        for incoming connections. &program_name; supports URLs with that start with
                        either "tcp://" or "quic://" such as: ["tcp://192.168.1.1:30001"] and
                        ["quic://192.168.1.1:40001"].</para>
                    <para><emphasis role="bold">Addresses</emphasis> is overridden if <emphasis
                            role="bold">BindAddresses</emphasis> is <emphasis role="bold"
                            >true</emphasis>. In that scenario, one or more advertised, external
                        addresses is provided as the value of <emphasis role="bold"
                            >Addresses</emphasis>, and is advertised in the PKI document.</para>
                    <para>Note that <emphasis role="bold">BindAddresses</emphasis>, below, holds the
                        address values for non-adverstised, internal-only listeners. The addition of
                            <emphasis role="bold">BindAddresses</emphasis> to the node configuration
                        is required for hosts connecting to the Internet through network adddress
                        translation (NAT).</para>
                    <para>Type: []string</para>
                    <para>Required: Yes</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">BindAddresses</emphasis></para>
                    <para>If <emphasis role="bold">true</emphasis>, allows setting of listener
                        addresses that the server will bind to and accept connections on. These
                        addresses are not advertised in the PKI document. For more information, see
                            <emphasis role="bold">Addresses</emphasis>, above.</para>
                    <para>Type: bool, []string</para>
                    <para>Required: No</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">MetricsAddress</emphasis></para>
                    <para>Specifies the address/port to bind the Prometheus metrics endpoint
                        to.</para>
                    <para>Type: string</para>
                    <para>Required: No</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">DataDir</emphasis></para>
                    <para>Specifies the absolute path to a node's state directory. This is where
                        persistence.db is written to disk and where a node stores its cryptographic
                        key materials when started with the "-g" commmand-line option.</para>
                    <para>Type: string</para>
                    <para>Required: Yes</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">IsGatewayNode</emphasis></para>
                    <para>If <emphasis role="bold">true</emphasis>, the server is a gateway
                        node.</para>
                    <para>Type: bool</para>
                    <para>Required: No</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">IsServiceNode</emphasis></para>
                    <para>If <emphasis role="bold">true</emphasis>, the server is a service
                        node.</para>
                    <para>Type: bool</para>
                    <para>Required: No</para>
                </listitem>
            </itemizedlist>
            
        </informalexample>
    </simplesect>

    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->   
    
    <!-- logging (/1/3) -->
    
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->   

    <simplesect>
        <title></title>
        <informalexample> 
            <para>The <code>Logging</code> configuration section controls logging behavior across &program_name;.</para>
            <programlisting>[Logging]
                Disable = false
                File = "katzenpost.log"
                Level = "INFO"</programlisting>
            <itemizedlist>
                <listitem>
                    <para><emphasis role="bold">Disable</emphasis></para>
                    <para>If <emphasis role="bold">true</emphasis>, logging is disabled.</para>
                    <para>Type: bool</para>
                    <para>Required: No</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">File</emphasis></para>
                    <para>Specifies the log file. If omitted, <code>stdout</code> is used.</para>
                    <para>An absolute or relative file path can be specified. A relative path is 
                    relative to the DataDir specified in the <code>Server</code> section of the 
                    configuration.</para>
                    <para>Type: string</para>
                    <para>Required: No</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Level</emphasis></para>
                    <para>Supported logging level values are ERROR | WARNING | NOTICE |INFO | DEBUG.</para>
                    <para>Type: string</para>
                    <para>Required: No</para>
                    <warning>
                        <para>The DEBUG log level is unsafe for
                            production use.</para>
                    </warning>                               
                </listitem>
            </itemizedlist>   
        </informalexample>
    </simplesect> 

    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->   
       
    <!-- sphinxgeometry (/1/4) -->
    
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->   
       
    <simplesect>
        <title></title>
        <informalexample>        
            <para>The <code>SphinxGeometry</code> section defines parameters for the Sphinx
                encrypted nested-packet format used internally by &program_name;. 
                <warning><para>The values in the <code>SphinxGeometry</code> configuration section must
                        be programmatically generated by <command>gensphinx</command>. Many of the
                        parameters are interdependent and cannot be individually modified. Do not
                        modify the these values by hand.</para></warning></para>
            <para>The settings in this section are generated by the <command>gensphinx</command>
                utility, which computes the Sphinx geometry based on the following user-supplied
                directives:</para>
            <itemizedlist>
                <listitem>
                    <para>The number of  mix node layers (not counting gateway and service
                        nodes)</para>
                </listitem>
                <listitem>
                    <para>The length of the application-usable packet payload</para>
                </listitem>
                <listitem>
                    <para>The selected NIKE or KEM scheme</para>
                </listitem>
            </itemizedlist>
            <para>The output in TOML should then be pasted unchanged into the node's configuration
                file, as shown below. For more information, 
                see <!-- <xref linkend="gensphinx"/> --><link xlink:href="&baseURL;docs/admin_guide/gensphinx-appendix.html">Appendix: 
                    Using gensphinx</link>.</para>
            <programlisting>[SphinxGeometry]
                PacketLength = 3082
                NrHops = 5
                HeaderLength = 476
                RoutingInfoLength = 410
                PerHopRoutingInfoLength = 82
                SURBLength = 572
                SphinxPlaintextHeaderLength = 2
                PayloadTagLength = 32
                ForwardPayloadLength = 2574
                UserForwardPayloadLength = 2000
                NextNodeHopLength = 65
                SPRPKeyMaterialLength = 64
                NIKEName = "x25519"
                KEMName = ""</programlisting>
            <itemizedlist>
                <listitem>
                    <para><emphasis role="bold">PacketLength</emphasis></para>
                    <para>The length of a Sphinx packet in bytes.</para>
                    <para>Type: int</para>
                    <para>Required: Yes</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">NrHops</emphasis></para>
                    <para>The number of hops a Sphinx packet takes through the mixnet. Because
                        packet headers hold destination information for each hop, the size of the
                        header increases linearly with the number of hops.</para>
                    <para>Type: int</para>
                    <para>Required: Yes</para>
                </listitem>                    
                <listitem>
                    <para><emphasis role="bold">HeaderLength</emphasis></para>
                    <para>The total length of the Sphinx packet header in bytes.</para>                   
                    <para>Type: int</para>
                    <para>Required: Yes</para>
                </listitem>                    
                <listitem>
                    <para><emphasis role="bold">RoutingInfoLength</emphasis></para>
                    <para>The total length of the routing information portion of the Sphinx packet
                        header.</para>
                    <para>Type: int</para>
                    <para>Required: Yes</para>
                </listitem>                    
                <listitem>
                    <para><emphasis role="bold">PerHopRoutingInfoLength</emphasis></para>
                    <para>The length of the per-hop routing information in the Sphinx packet
                        header.</para>
                    <para>Type: int</para>
                    <para>Required: Yes</para>
                </listitem>                    
                <listitem>
                    <para><emphasis role="bold">SURBLength</emphasis></para>
                    <para>The length of a single-use reply block (SURB).</para>
                    <para>Type: int</para>
                    <para>Required: Yes</para>
                </listitem>                    
                <listitem>
                    <para><emphasis role="bold">SphinxPlaintextHeaderLength</emphasis></para>
                    <para>The length of the plaintext Sphinx packet header.</para>
                    <para>Type: int</para>
                    <para>Required: Yes</para>
                </listitem>                    
                <listitem>
                    <para><emphasis role="bold">PayloadTagLength</emphasis></para>
                    <para>The length of the payload tag.</para>
                    <para>Type: int</para>
                    <para>Required: Yes</para>
                </listitem>                    
                <listitem>
                    <para><emphasis role="bold">ForwardPayloadLength</emphasis></para>
                    <para>The total size of the payload.</para>
                    <para>Type: int</para>
                    <para>Required: Yes</para>
                </listitem>                    
                <listitem>
                    <para><emphasis role="bold">UserForwardPayloadLength</emphasis></para>
                    <para>The size of the usable payload.</para>
                    <para>Type: int</para>
                    <para>Required: Yes</para>
                </listitem>       
                <listitem>
                    <para><emphasis role="bold">NextNodeHopLength</emphasis></para>
                    <para>The <code>NextNodeHopLength</code> is derived from the largest routing-information 
                        block that we expect to encounter. Other packets have 
                        <code>NextNodeHop</code> + <code>NodeDelay</code> sections, or a <code>Recipient</code> section, both of which
                        are shorter.</para>
                    <para>Type: int</para>
                    <para>Required: Yes</para>
                </listitem>  
                <listitem>
                    <para><emphasis role="bold">SPRPKeyMaterialLength</emphasis></para>
                    <para>The length of the strong pseudo-random permutation (SPRP) key.</para>
                    <para>Type: int</para>
                    <para>Required: Yes</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">NIKEName</emphasis></para>
                    <para>The name of the non-interactive key exchange (NIKE) scheme used by Sphinx
                        packets.</para>
                    <para><code>NIKEName</code> and <code>KEMName</code> are mutually
                        exclusive.</para>
                    <para>Type: string</para>
                    <para>Required: Yes</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">KEMName</emphasis></para>
                    <para>The name of the key encapsulation mechanism (KEM) used by Sphinx
                        packets.</para>
                    <para><code>NIKEName</code> and <code>KEMName</code> are mutually exclusive.</para>
                    <para>Type: string</para>
                    <para>Required: Yes</para>
                </listitem>
            </itemizedlist>            
        </informalexample>
    </simplesect>           
 
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->   
    
    <!-- management (/1/5) -->
    
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->   
   
    <simplesect>
        <title></title>
           <informalexample> 
           <para>The <code>Management</code> section specifies connectivity information for the
                &program_name; control protocol which can be used to make run-time configuration
                changes. A configuration resembles the following, substituting the node's configured
                    <code>DataDir</code> value as part of the <code>Path</code> value:</para>
           <programlisting>[Management]
   Enable = false
   Path = "/<replaceable>node_datadir</replaceable>/management_sock"</programlisting>
           <itemizedlist>
               <listitem>
                   <para><emphasis role="bold">Enable</emphasis></para>
                   <para>If <emphasis role="bold">true</emphasis>, the management interface is
                        enabled.</para>
                   <para>Type: bool</para>
                   <para>Required: No</para>
               </listitem>
               <listitem>
                   <para><emphasis role="bold">Path</emphasis></para>
                   <para>Specifies the path to the management interface socket. If left empty, then <code>management_sock</code> 
                       is located in the configuration's defined <code>DataDir</code>.</para>
                   <para>Type: string</para>
                   <para>Required: No</para>
               </listitem>
           </itemizedlist>
       </informalexample>
    </simplesect> 

    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->   
    
    <!-- pki (/1/6)-->
    
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->   
        
    <simplesect>
        <title></title>     
        <informalexample> 
            <para>The <code>PKI</code> section contains the directory authority configuration for a mix, gateway, or service node.</para>
            <programlisting>[PKI]
[PKI.dirauth]

    [[PKI.dirauth.Authorities]]
        Identifier = "auth1"
        IdentityPublicKey = """-----BEGIN ED25519 PUBLIC KEY-----
tqN6tpOVotHWXKCszVn2kS7vAZjQpvJjQF3Qz/Qwhyg=
-----END ED25519 PUBLIC KEY-----
"""
        PKISignatureScheme = "Ed25519"
        LinkPublicKey = """-----BEGIN XWING PUBLIC KEY-----
JnJ8ztQEIjAkKJcpuZvJAdkWjBim/5G5d8yoosEQHeGJeeBqNPdm2AitUbpiQPcd
tNCo9DxuC9Ieqmsfw0YpV6AtOOsaInA6QnHDYcuBfZcQL5MU4+t2TzpBZQYlrSED
hPCKrAG+8GEUl6akseG371WQzEtPpEWWCJCJOiS/VDFZT7eKrldlumN6gfiB84sR
...
arFh/WKwYJUj+aGBsFYSqGdzC6MdY4x/YyFe2ze0MJEjThQE91y1d/LCQ3Sb7Ri+
u6PBi3JU2qzlPEejDKwK0t5tMNEAkq8iNrpRTdD/hS0gR+ZIN8Z9QKh7Xf94FWG2
H+r8OaqImQhgHabrWRDyLg==
-----END XWING PUBLIC KEY-----
"""
        WireKEMScheme = "xwing"
        Addresses = ["127.0.0.1:30001"]

    [[PKI.dirauth.Authorities]]
        Identifier = "auth2"
        IdentityPublicKey = """-----BEGIN ED25519 PUBLIC KEY-----
O51Ty2WLu4C1ETMa29s03bMXV72gnjJfTfwLV++LVBI=
-----END ED25519 PUBLIC KEY-----	
"""
        PKISignatureScheme = "Ed25519"
        LinkPublicKey = """-----BEGIN XWING PUBLIC KEY-----
TtQkg2XKUnY602FFBaPJ+zpN0Twy20cwyyFxh7FNUjaXA9MAJXs0vUwFbJc6BjYv
f+olKnlIKFSmDvcF74U6w1F0ObugwTNKNxeYKPKhX4FiencUbRwkHoYHdtZdSctz
TKy08qKQyCAccqCRpdo6ZtYXPAU+2rthjYTOL7Zn+7SHUKCuJClcPnvEYjVcJxtZ
...
ubJIe5U4nMJbBkOqr7Kq6niaEkiLODa0tkpB8tKMYTMBdcYyHSXCzpo7U9sb6LAR
HktiTBDtRXviu2vbw7VRXhkMW2kjYZDtReQ5sAse04DvmD49zgTp1YxYW+wWFaL3
37X7/SNuLdHX4PHZXIWHBQ==
-----END XWING PUBLIC KEY-----	
"""
        WireKEMScheme = "xwing"
        Addresses = ["127.0.0.1:30002"]

    [[PKI.dirauth.Authorities]]
        Identifier = "auth3"
        IdentityPublicKey = """-----BEGIN ED25519 PUBLIC KEY-----
zQvydRYJq3npeLcg1NqIf+SswEKE5wFmiwNsI9Z1whQ=
-----END ED25519 PUBLIC KEY-----
"""
        PKISignatureScheme = "Ed25519"
        LinkPublicKey = """
-----BEGIN XWING PUBLIC KEY-----
OYK9FiC53xwZ1VST3jDOO4tR+cUMSVRSekmigZMChSjDCPZbKut8TblxtlUfc/yi
Ugorz4NIvYPMWUt3QPwS2UWq8/HMWXNGPUiAevg12+oV+jOJXaJeCfY24UekJnSw
TNcdGaFZFSR0FocFcPBBnrK1M2B8w8eEUKQIsXRDM3x/8aRIuDif+ve8rSwpgKeh
...
OdVD3yw7OOS8uPZLORGQFyJbHtVmFPVvwja4G/o2gntAoHUZ2LiJJakpVhhlSyrI
yuzvwwFtZVfWtNb5gAKZCyg0aduR3qgd7MPerRF+YopZk3OCRpC02YxfUZrHv398
FZWJFK0R8iU52CEUxVpXTA==
-----END XWING PUBLIC KEY-----	
"""
        WireKEMScheme = "xwing"
        Addresses = ["127.0.0.1:30003"]</programlisting>
            <itemizedlist>
                <listitem>
                    <para><emphasis role="bold">Identifier</emphasis></para>
                    <para>Specifies the human-readable identifier for a node, which must be unique per mixnet. 
                    The identifier can be an FQDN but does not have to be.</para>
                    <para>Type: string</para>
                    <para>Required: Yes</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">IdentityPublicKey</emphasis></para>
                    <para>String containing the node&apos;s public identity key in PEM format.
                            <code>IdentityPublicKey</code> is the node&apos;s permanent identifier
                        and is used to verify cryptographic signatures produced by its private
                        identity key.</para>
                    <para>Type: string</para>
                    <para>Required: Yes</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">PKISignatureScheme</emphasis></para>
                    <para>Specifies the cryptographic signature scheme that will be used by all
                        components of the mix network when interacting with the PKI system. Mix
                        nodes sign their descriptors using this signature scheme, and dirauth nodes
                        similarly sign PKI documents using the same scheme.</para>
                    <para>Type: string</para>
                    <para>Required: Yes</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">LinkPublicKey</emphasis></para>
                    <para>String containing the peer&apos;s public link-layer key in PEM format.
                            <code>LinkPublicKey</code> must match the specified
                            <code>WireKEMScheme</code>.</para>
                    <para>Type: string</para>
                    <para>Required: Yes</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">WireKEMScheme</emphasis></para>
                    <para>The name of the wire protocol key-encapsulation mechanism (KEM) to use.</para>
                    <para>Type: string</para>
                    <para>Required: Yes</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Addresses</emphasis></para>
                    <para>Specifies a list of one or more address URLs in a format that contains the
                        transport protocol, IP address, and port number that the server will bind to
                        for incoming connections. &program_name; supports URLs that start with
                        either "tcp://" or "quic://" such as: ["tcp://192.168.1.1:30001"] and
                        ["quic://192.168.1.1:40001"]. The value of <emphasis role="bold"
                            >Addresses</emphasis> is advertised in the PKI document.</para>
                    <para>Type: []string</para>
                    <para>Required: Yes</para>
                </listitem>
            </itemizedlist>                            
        </informalexample>
    </simplesect> 
    
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->   
    
    <!-- serverdebug (/1/7) -->
    
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->
    <!--##################################################-->    
    
    <simplesect>
        <title></title>     
        <informalexample>    
            <para>The <code>Debug</code> section is the &program_name; server debug configuration
                for advanced tuning.</para>   
            <programlisting>[Debug]
                NumSphinxWorkers = 16
                NumServiceWorkers = 3
                NumGatewayWorkers = 3
                NumKaetzchenWorkers = 3
                SchedulerExternalMemoryQueue = false
                SchedulerQueueSize = 0
                SchedulerMaxBurst = 16
                UnwrapDelay = 250
                GatewayDelay = 500
                ServiceDelay = 500
                KaetzchenDelay = 750
                SchedulerSlack = 150
                SendSlack = 50
                DecoySlack = 15000
                ConnectTimeout = 60000
                HandshakeTimeout = 30000
                ReauthInterval = 30000
                SendDecoyTraffic = false
                DisableRateLimit = false
                GenerateOnly = false</programlisting>
                <itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">NumSphinxWorkers</emphasis></para>
                        <para>Specifies the number of worker instances to use for inbound Sphinx
                            packet processing.</para>
                        <para>Type: int</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">NumProviderWorkers</emphasis></para>
                        <para>Specifies the number of worker instances to use for provider specific
                            packet processing.</para>
                        <para>Type: int</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">NumKaetzchenWorkers</emphasis></para>
                        <para>Specifies the number of worker instances to use for Kaetzchen-specific
                        packet processing.</para>
                        <para>Type: int</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">SchedulerExternalMemoryQueue</emphasis></para>
                        <para>If <emphasis role="bold">true</emphasis>, the experimental disk-backed external memory 
                            queue is enabled.</para>
                        <para>Type: bool</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">SchedulerQueueSize</emphasis></para>
                        <para>Specifies the maximum scheduler queue size before random entries will
                        start getting dropped. A value less than or equal to zero is treated as
                        unlimited.</para>
                        <para>Type: int</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">SchedulerMaxBurst</emphasis></para>
                        <para>Specifies the maximum number of packets that will be dispatched per
                            scheduler wakeup event.</para>
                        <para>Type: </para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">UnwrapDelay</emphasis></para>
                        <para>Specifies the maximum unwrap delay due to queueing in
                            milliseconds.</para>
                        <para>Type: int</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">GatewayDelay</emphasis></para>
                        <para>Specifies the maximum gateway node worker delay due to queueing in milliseconds.</para>
                        <para>Type: int</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">ServiceDelay</emphasis></para>
                        <para>Specifies the maximum provider delay due to queueing in
                            milliseconds.</para>
                        <para>Type: int</para>
                        <para>Required: No</para> 
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">KaetzchenDelay</emphasis></para>
                        <para>Specifies the maximum kaetzchen delay due to queueing in
                            milliseconds.</para>
                        <para>Type: int</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">SchedulerSlack</emphasis></para>
                        <para>Specifies the maximum scheduler slack due to queueing and/or
                            processing in milliseconds.</para>
                        <para>Type: int</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">SendSlack</emphasis></para>
                        <para>Specifies the maximum send-queue slack due to queueing and/or
                            congestion in milliseconds.</para>
                        <para>Type: int</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">DecoySlack</emphasis></para>
                        <para>Specifies the maximum decoy sweep slack due to external
                            delays such as latency before a loop decoy packet will be considered
                            lost.</para>
                        <para>Type: int</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">ConnectTimeout</emphasis></para>
                        <para>Specifies the maximum time a connection can take to establish a
                            TCP/IP connection in milliseconds.</para>
                        <para>Type: int</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">HandshakeTimeout</emphasis></para>
                        <para>Specifies the maximum time a connection can take for a link-protocol
                            handshake in milliseconds.</para>
                        <para>Type: int</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">ReauthInterval</emphasis></para>
                        <para>Specifies the interval at which a connection will be reauthenticated
                            in milliseconds.</para>
                        <para>Type: int</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">SendDecoyTraffic</emphasis></para>
                        <para>If <emphasis role="bold">true</emphasis>, decoy traffic is enabled. 
                            This parameter is experimental and untuned, 
                            and is disabled by default.</para>
                        <note>
                            <para>This option will be removed once decoy traffic is fully implemented.</para>
                        </note>
                        <para>Type: bool</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">DisableRateLimit</emphasis></para>
                        <para>If <emphasis role="bold">true</emphasis>, the per-client rate limiter is disabled.</para>
                        <note>
                            <para>This option should only be used for testing.</para>
                        </note>
                        <para>Type: bool</para>
                        <para>Required: No</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">GenerateOnly</emphasis></para>
                        <para>If <emphasis role="bold">true</emphasis>, the server immediately halts
                        and cleans up after long-term key generation.</para>
                        <para>Type: bool</para>
                        <para>Required: No</para>
                    </listitem>
                </itemizedlist>
        </informalexample> 
    </simplesect>
</chapter>
